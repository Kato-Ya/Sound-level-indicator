# Sound-level-indicator
Описание работы устройства

Используется аудио генератор, в который загружается файл с расширением «wav». После микрофона на схеме крепится конденсатор C6 для фильтрации шумов, поступающих с микрофона.
После конденсатора идет операционный усилитель LM386, который служит усилителем сигнала, который выходит с выхода конденсаторного микрофона.
Коэффициент усиления используемого нами операционного усилителя LM386 может составлять от 20 до 200 в зависимости от номинала конденсатора или резистора, подключенного к его контактам 1 и 8. Если их не использовать совсем, то коэффициент усиления будет равен 20, то есть минимальному значению. Чтобы использовать максимальный коэффициент усиления, то между контактами 1 и 8 необходим конденсатор C8, емкость которого равна 10 мкФ. Вся схема усилителя запитывается от контакта AVCC Atmega8.

Конденсатор C6 используется для фильтрации шумов, поступающих с 
микрофона. Когда микрофон начинает получать .wav сигнал. На его выходе появляется сигнал переменного тока. Но в составе этого сигнала переменного тока может присутствовать шум с некоторым постоянным уровнем (постоянная составляющая сигнала), этот шум и отфильтровывается с помощью данного конденсатора. Аналогично этому конденсатор C9 на выходе усилителя используется для фильтрации постоянного уровня шумов, которые могли появиться в процесс усиления сигнала (добавиться к нему в процессе усиления).

Схема сбора сигнала с микрофона представлена ниже:

 ![image](https://github.com/Kato-Ya/Sound-level-indicator/assets/121151393/2b851f18-f286-4188-806c-640d063eb682)

Рисунок 1 – Схема фильтра для поступающего сигнала

	На порт PC1/ADC1 микроконтроллера приходит сигнал, который обрабатывается в микроконтроллере atmega8. Далее, в зависимости величины поданного сигнала будет загораться определенное число светодиодов. На выход установлены порты PORTB, с них будет считываться сигнал. Перед светодиодами поставлены резисторы предохранители с размером сопротивления в 200 Ом.
 
 ![image](https://github.com/Kato-Ya/Sound-level-indicator/assets/121151393/1a695479-7d5d-4ad2-b99c-6390b833adcb)

Рисунок 2 – Индикаторы звука
	 
Ниже представлены условия свечения светодиодов:
Если уровень звука превышает 0 ДБ, но ниже, чем 15 ДБ, загорается первый ряд светодиодов – PBO.
Если уровень звука превышает 15 ДБ, но ниже, чем 30 ДБ, загорается первый и второй ряд светодиодов – PBO и PB1.
Если уровень звука превышает 30 ДБ, но ниже, чем 45 ДБ, загорается первый, второй и третий ряд светодиодов – PBO, PB1 и PB2.
Если уровень звука превышает 30 ДБ, но ниже, чем 45 ДБ, загорается первый, второй, третий и четвертый ряд светодиодов – PBO, PB1, PB2 и PB3.
Если уровень звука превышает 45 ДБ, но ниже, чем 60 ДБ, загорается первый, второй, третий, четвертый и пятый ряд светодиодов – PBO, PB1, PB2, PB3 и PB4.
Если уровень звука превышает 60 ДБ, но ниже, чем 75 ДБ, загорается первый, второй, третий, четвертый, пятый и шестой ряд светодиодов – PBO, PB1, PB2, PB3, PB4 и PB5.
Если уровень звука превышает 75 ДБ, но ниже, чем 90 ДБ, загорается первый, второй, третий, четвертый, пятый, шестой и седьмой ряд светодиодов – PBO, PB1, PB2, PB3, PB4, PB5 и PB6.
Если уровень звука превышает 90 ДБ, но ниже, чем 105 ДБ, загорается первый, второй, третий, четвертый, пятый, шестой и седьмой ряд светодиодов – PBO, PB1, PB2, PB3, PB4, PB5, PB6 и PB7.
Если уровень звука превышает 105 ДБ, но ниже, чем 120 ДБ, загорается первый, второй, третий, четвертый, пятый, шестой, седьмой и восьмой ряд светодиодов – PBO, PB1, PB2, PB3, PB4, PB5, PB6, PB7 и PD5.
Если уровень звука превышает 120 ДБ, но ниже, чем 135 ДБ, загорается первый, второй, третий, четвертый, пятый, шестой, седьмой и восьмой ряд светодиодов – PBO, PB1, PB2, PB3, PB4, PB5, PB6, PB7, PD5 и PD4.
Если уровень звука превышает 135 ДБ, то загораются все ряды светодиодов.
Вся схема выглядит следующим образом:

 ![image](https://github.com/Kato-Ya/Sound-level-indicator/assets/121151393/53936a01-3a5f-40e9-a587-f30ebe3fb510)

Рисунок 3 – Принципиальная схема индикатора

Программа для данной работы выполняется следующим образом:
Изначально в коде объявляется частота МК, с которой он будет работать, важно указать ее до подключения библиотек.
Подключается библиотека, отвечающая за работу с микроконтроллерами AVR – avr /io.h. В нашем случае, это микроконтроллер ATMEGA8. Далее необходимо подключить библиотеку, связанную с задержкой – util/delay.h, она позволяет включать в программу задержку между различными операциями, проводимых в симуляции для корректного отображения данных. Следующей необходимой библиотекой стали прерывания avr/interrupt.h. Прерывания необходимы для верного переключения работы между разными блоками. Также добавили таймер счетчик, который работает через прерывания.
	Создана функция ADC_set, которая определяет настройку параметров АЦП. Необходимо задать настройку АЦП, чтобы понять с каким сигналом придется работать в симуляции. Здесь же выбираем, в какой порт будет поступать отфильтрованный сигнал с микрофона.
	Функция Timer_counter_set определяет режим работы таймер-счетчика, устанавливая режим СТС и делитель частоты равный 256. В регистр сравнения OCR1A записываем значение 127, то есть такое, до которого будет доходить таймер, а далее сбрасывать значение в нуль. С  помощью регистра TIMSK активируем режим прерывания по совпадению. Для того чтобы преобразование работало, каждый раз, значение АЦП будет записываться в массив после начала единичного преобразования АЦП, чтобы так происходило, была объявлена глобальная переменная value, которая записывает каждый раз новое значение ADCH(adc_arr[value] = ADCH; value++;).
	Для вычисления значения OCR1A использовалась точка сравнения. Точка сравнения является значением, с которым сравнивается величина, достигнутая таймером. Существует формула для расчета OCR1A = (F_CPU / (предделитель * частота)) /64, где F_CPU - частота работы. В данном случае, частота – 0,5 Гц, что соответствует значению счетчика таймера 122 (предделителю частоты 256).
Прерывание будет срабатывать каждую секунду, потому что значение точки сравнения выбирается таким образом, чтобы создать прерывание с заданной частотой (здесь – 0,5 Гц). Таким образом, после каждого срабатывания прерывания, счетчик будет сбрасываться и начинать отсчет заново. Таким образом, прерывание будет вызываться каждую секунду (так как полный период счетчика таймера составляет 2 секунды - 122 / 1 МГц * 256).
	Пишем функцию PORTS, тем самым определяя, какие порты пойдут на выход, а какие на вход. В нашем случае порты «B» идут на выход, где сигнал выходит на определенные светодиоды, в то время как порты «С» идут на вход, где принимается отфильтрованный сигнал. Также направим на выход два порта D.
	Для начала запустим работу, где дается разрешение на работу АЦП и ставятся порты на вход и выход. Для того чтобы произвести обработку данных, нам необходимо перед циклом while(1), который отвечает за работу, происходящую на схеме, поставить флаг глобального прерывания. И перенести все действия, связанные с конвертированием сигнала с помощью формулы, полученной в результате проведения метода регрессионного анализа в отдельную функцию прерывания по АЦП вне функции main. Также глобальное прерывание переносит программу на функцию прерывания по таймеру, который включает в себя способ записи амплитуды среди значений в 200 точек за один ход сигнала с частотой 0.5 Гц в массив ADC со счетчиком i. В данном массиве находятся максимальное и минимальное значение среди 200 точек и вычитается из большего меньшее для нахождение амплитуды за один ход программы (200 точек). Прерывание по таймеру отвечает за единичное преобразование АЦП и за запись значения ADCH в массив и увеличение счетчика данных значений.
	Для начала необходимо провести измерения АЦП. Присвоим всем выводящим портам значение ADCH: PORTB = ADCH и PORTD = ADCH. Для взятия показаний АЦП необходимо было загрузить такой же звуковой файл в микрофон формата .wav. Далее данный сигнал передается на спикер с номинальным напряжением 1В. Каждый раз, при повышении шкалы спикера на 0.1 В  проводились измерения АЦП с выводящих портов PORTB. Каждый из выводящих портов имеет свою разрядность. После того, как индикаторы загорелись от конкретных портов, необходимо суммировать выведенные биты. В зависимости от напряжения, показанного на спикере, будет подаваться сигнал с определенных портов. 
 
 ![image](https://github.com/Kato-Ya/Sound-level-indicator/assets/121151393/b8be1821-26ba-4bbd-ad4c-71dc352d1f6e)

Рисунок 4 – Проведение измерения АЦП
Посмотрев, на загорающиеся значения, заносим в таблицу значения ADC и показатели напряжения (шага) на спикере.
Также существует способ нахождения дБ (разы) с помощью формулы
dB=20×lg⁡(U_вых/U_вх )
Для этого необходимо измерить напряжение на выходе и входе с помощью аналогового вольтметра:

 ![image](https://github.com/Kato-Ya/Sound-level-indicator/assets/121151393/9030b805-ac7c-4410-b516-31b1af906123)

Рисунок 5 – Проведение измерений подаваемого напряжения на входе и выходе операционного усилителя
Далее соотнесем полученные значения по всем способам измерений и занесем в таблицу:

 ![image](https://github.com/Kato-Ya/Sound-level-indicator/assets/121151393/24c3ebc1-b976-4016-b3ea-ce6ccaa72796)

Рисунок 6 – Таблица данных для расчетов дБ
Проведем регрессионный анализ по данным, полученным в результате калибровки спикера, то есть его данных шага по напряжению и индикации битов с выходов порта PORTB с помощью светодиодов.
Построим график АЦП и проведем линию тренда для проведения аппроксимации:

 ![image](https://github.com/Kato-Ya/Sound-level-indicator/assets/121151393/1a215dad-0fca-4c8e-a2fb-3bfb81c112aa)

Рисунок 7 – График АЦП
Полученный график не имеет линейной зависимости. Следовательно, нельзя пересчитать АЦП в разы. Для обхода данной проблемы, будет использован метод линейной регрессии.  Смысл данного метода заключается в том, чтобы аппроксимировать график ADCH к линии тренда – «Линейная(ADCH)». Благодаря данному методу, будет возможным найти эквивалентное значение АЦП в разы.
Для данной работы был установлен пакет в excel под названием «Анализ данных» и из предложенного списка, был выбран метод «Регрессия». Далее была сделана выборка по значением регрессии, где нам необходимо внести результаты, которые мы пытаемся установить по Y, а также по X ставим результаты влияние на переменную которого мы хотим установить:

 ![image](https://github.com/Kato-Ya/Sound-level-indicator/assets/121151393/4dde309f-65c3-41b1-9a06-f4bf1feac06b)

Рисунок 9 – Настройка регрессии

 ![image](https://github.com/Kato-Ya/Sound-level-indicator/assets/121151393/cd829263-1857-467b-ac26-f8797033012e)

Рисунок 10 – Итоги регрессии
Далее возьмем коэффициенты и попробуем подставить под формулу:
ADC=(1.8×dB(разы))-45.63636
Отсюда выведем значение дБ:
dB(разы)= (ADC+ 45.63636)/1.8
Данная формула использовалась для конвертации данных АЦП в дБ (разы). 
