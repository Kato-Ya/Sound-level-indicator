/*
 * GccApplication2.c
 *
 * Created: 21.04.2023 15:16:18
 * Author : Alexander
 */ 

#define F_CPU 1000000UL

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

unsigned char arr_adc[200];// создаем массив для записи значений АЦП
//передать в функцию и обработать максимальный и минимальный элементы данного массива
double db;
//void DB()
//{
	//// используем уравнение регрессии для перевода значения АЦП в дБ
	////db = ADCH; // считываем значение АЦП
	//db = ((ADCH + 520.681) /23.633); // перевод АЦП в децибелы, используя значения из уравнения регрессии
//}
//void arr_adc_processing()
//{
	//int max_value = arr_adc[0];			
	//int min_value = arr_adc[0];
	//
	//for (int i =0; i < arr_adc.size(); i++)
	//{
		//if (max_value < arr_adc[i])
        //{
            //max_value = arr_adc[i];
        //}
		//else if(min_value > arr_adc[i])
		//{
			//min_value = arr_adc[i];
		//}
		////после нахождения наибольшего и наименьшего элементов нашего массива, вычислим амплитуду
		//int diff_bet_max_min = max_value - min_value;
		//
	//}
//}

void PORTS()
{
	DDRB = 0xFF;
	DDRC = 0x00;
}
void ADC_set()
{
	//Регистр выбора мультиплексора
	ADMUX = (0 << REFS1) | (1 << REFS0) | (1 << ADLAR); //внутренний источник опорного напряжение - напряжение питания
	ADMUX |= (0 << MUX3) | (0 << MUX2) | (0 << MUX1) | (1 << MUX0); //ацп на ADC1
	//ADC Status and Control Registor A - ADCSRA
	//ставим 1 в 7 бит на разрешение работы АЦП
	//ставим 1 в 5 бит на постоянную обработку сигнала
	ADCSRA = (1 << ADEN) | (1 << ADSC)| (1 << ADFR) | (1 << ADIE) | (0 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);
}
int main(void)
{
	PORTS();
	ADC_set();
	//DB();
	//arr_adc_processing()
	sei(); //установка флага глобального прерывания
	while (1)
	{
		
	}
}
ISR(ADC_vect)//обработчик прерываний
{
	
	PORTB = ADCH;
	PORTD = ADCH;
	//int max_value = arr_adc[0];
	//int min_value = arr_adc[0];
		//
	//for (int i =0; i < arr_adc[200]; i++)
	//{
		//if (max_value < arr_adc[i])
		//{
			//max_value = arr_adc[i]; //наиб точка из 200
		//}
		//else if(min_value > arr_adc[i])
		//{
			//min_value = arr_adc[i];//наим. точка из 200
		//}
		////после нахождения наибольшего и наименьшего элементов нашего массива, вычислим амплитуду
		//int diff_bet_max_min = max_value - min_value;
	//}
			//
	//if (db > 0 && db < 15) // если уровень звука от 0 до 15 дБа
	//{
		//PORTB = (1 << 0); // загорается первый светодиод
	//}
	//else if (db >= 15 && db < 30) // если уровень звука от 15 до 30 дБа
	//{
		//PORTB = (1 << 0) | (1 << 1); // загораются первый и второй светодиоды
	//}
	//else if (db >= 30 && db < 45) // если уровень звука от 30 до 45 дБа
	//{
		//PORTB = (1 << 0) | (1 << 1) | (1 << 2); // загораются первый, второй и третий светодиоды
	//}
	//else if (db >= 45 && db < 60) // если уровень звука от 45 до 60 дБа
	//{
		//PORTB = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3); // загораются первый, второй, третий и четвертый светодиоды
	//}
	//else if (db >= 60 && db < 75) // если уровень звука от 60 до 75 дБа
	//{
		//PORTB = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4); // загораются первый, второй, третий, четвертый и пятый светодиоды
	//}
	//else if (db >= 75 && db < 90) // если уровень звука от 75 до 90 дБа
	//{
		//PORTB = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5); // загораются первый, второй, третий, четвертый, пятый и шестой светодиоды
	//}
	//else if (db >= 90 && db < 105) // если уровень звука от 90 до 105 дБа
	//{
		//PORTB = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5)| (1 << 6); // загораются первый, второй, третий, четвертый, пятый, шестой и седьмой светодиоды
	//}
		//else if (db >= 105) // если уровень звука от 105 до 120 дБа
		//{
			////PORTB = (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5)| (1 << 6)| (1 << 7) | (1 << 8); // загораются все светодиоды
			//PORTB = 0xFF;
		//}
}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///*
//
//GccApplication2.c
//Created: 21.04.2023 15:16:18
//Author : Alexander */
//#define F_CPU 800000UL
//
//#include <avr/io.h>
//#include <util/delay.h>
//#include <avr/interrupt.h>
//
//unsigned char db;
//unsigned char Pdb;
//
//void PORTS()
//{
	//DDRB = 0xFF;
	//DDRC = 0x00;
//}
//
//void ADC_set()
//{
	////Регистр выбора мультиплексора
	//ADMUX = (0 << REFS1) | (1 << REFS0) | (1 << ADLAR); //внутренний источник опорного напряжение - напряжение питания
	//ADMUX |= (0 << MUX3) | (0 << MUX2) | (0 << MUX1) | (1 << MUX0); //ацп на ADC1
	////ADC Status and Control Registor A - ADCSRA
	////ставим 1 в 7 бит на разрешение работы АЦП
	////ставим 1 в 5 бит на постоянную обработку сигнала
	//ADCSRA = (1 << ADEN) | (1 << ADSC)| (1 << ADFR) | (1 << ADIE) | (0 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);
//}
//
//void DB()
//{
	//// используем уравнение регрессии для перевода значения АЦП в дБ
	//int voltage = ADCH * 4; // напряжение на входе АЦП, масштабированное на 4
	//int dB = 50.0 * log10(voltage / 1024.0) + 29.0;	
	//db = dB; // сохраняем значение дБ
//}
//
//int main(void)
//{
	//PORTS();
	//ADC_set();
	//sei(); //установка флага глобального прерывания
//
	//while (1)
	//{
		//_delay_ms(200); // ждем 200 мс перед новым измерением
	//}
//}
//
//ISR(ADC_vect)//обработчик прерываний
//{
	//Pdb = db; // сохраняем предыдущее значение дБ
	//DB(); // получаем новое значение дБ
//
	//// определяем, сколько светодиодов должно загореться в зависимости от уровня звука
	//if (db < 15) {
		//PORTB = 0b00000001;
		//} else if (db < 30) {
		//PORTB = 0b00000011;
		//} else if (db < 45) {
		//PORTB = 0b00000111;
		//} else if (db < 60) {
		//PORTB = 0b00001111;
		//} else if (db < 75) {
		//PORTB = 0b00011111;
		//} else if (db < 90) {
		//PORTB = 0b00111111;
		//} else if (db < 105) {
		//PORTB = 0b01111111;
		//} else {
		//PORTB = 0b11111111;
	//}
//}



//#define F_CPU 8000000UL //обязательно указываем с какой частотой будет работать мк, т.к. будет выходить предупреждение.
//// Объявление частоты работы мк также является необходимым до заголовочного файла "util/delay.h",
//// поскольку только так будет верно рассчитан цикл задержки функции "delay"
//
//#include <avr/io.h>
//#include <util/delay.h>
//
//
//PORT_set()
//{
	//DDRC = 0x00; //Объявляем порты B на вход
	//DDRB = 0xFF; //Объявляем порт D на выход
//}
//
//int main(void)
//{
	//PORT_set();
	//while(1)   //Запускаем цикл
	//{
		//double db;
		//db = ADCH; // считываем значение АЦП
		//db = ((ADCH + 83.2073) / 11.003); // перевод АЦП в децибелы, используя значения из уравнения регрессии
		//if (db > 0 && db < 15) // если уровень звука от 0 до 15 дБа
		//{
			//PORTB = (1 << 0); // загорается первый светодиод
		//}
		//else if (db >= 15 && db < 30) // если уровень звука от 15 до 30 дБа
		//{
			//PORTB = (1 << 0) | (1 << 1); // загораются первый и второй светодиоды
		//}
		//else if (db >= 30 && db < 45) // если уровень звука от 30 до 45 дБа
		//{
			//PORTB = (1 << 0) | (1 << 1) | (1 << 2); // загораются первый, второй и третий светодиоды
		//}
		//else if (db >= 45 && db < 60) // если уровень звука от 45 до 60 дБа
		//{
			//PORTB = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3); // загораются первый, второй, третий и четвертый светодиоды
		//}
		//else if (db >= 60 && db < 75) // если уровень звука от 60 до 75 дБа
		//{
			//PORTB = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4); // загораются первый, второй, третий, четвертый и пятый светодиоды
		//}
		//else if (db >= 75 && db < 90) // если уровень звука от 75 до 90 дБа
		//{
			//PORTB = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5); // загораются первый, второй, третий, четвертый, пятый и шестой светодиоды
		//}
		//else if (db >= 90 && db < 105) // если уровень звука от 90 до 105 дБа
		//{
			//PORTB = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5)| (1 << 6); // загораются первый, второй, третий, четвертый, пятый, шестой и седьмой светодиоды
		//}
		//else if (db >= 105) // если уровень звука от 105 до 120 дБа
		//{
			////PORTB = (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5)| (1 << 6)| (1 << 7) | (1 << 8); // загораются все светодиоды
			//PORTB = 0xFF;
		//}
		//_delay_ms(200); // ждем 200 мс перед новым измерением
	//}
//}
